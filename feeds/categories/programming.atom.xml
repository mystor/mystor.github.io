<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Nika's Box - Programming</title><link href="https://mystor.github.io/" rel="alternate"></link><link href="https://mystor.github.io/feeds/categories/programming.atom.xml" rel="self"></link><id>https://mystor.github.io/</id><updated>2018-11-24T12:00:00-05:00</updated><entry><title>Partially Generated Classes in C++</title><link href="https://mystor.github.io/partial-cxx-codegen.html" rel="alternate"></link><published>2018-11-24T12:00:00-05:00</published><updated>2018-11-24T12:00:00-05:00</updated><author><name>Nika Layzell</name></author><id>tag:mystor.github.io,2018-11-24:/partial-cxx-codegen.html</id><summary type="html">&lt;p&gt;An interesting problem which I've seen come up decently often in C++ code generators is how to deal with what I'm calling "partially generated classes". We want to generate methods and members for a class which call other methods on that class added by the implementation.&lt;/p&gt;
&lt;h2&gt;Potential Solutions&lt;/h2&gt;
&lt;p&gt;I'm not …&lt;/p&gt;</summary><content type="html">&lt;p&gt;An interesting problem which I've seen come up decently often in C++ code generators is how to deal with what I'm calling "partially generated classes". We want to generate methods and members for a class which call other methods on that class added by the implementation.&lt;/p&gt;
&lt;h2&gt;Potential Solutions&lt;/h2&gt;
&lt;p&gt;I'm not sure what the "best" solution is in this case, but I figured I'd enumerate some of the options avaliable to us with an example. We'll look at how each of these dynamically route a call to a series of impl-defined calls.&lt;/p&gt;
&lt;h3&gt;Virtual Methods&lt;/h3&gt;
&lt;p&gt;The most obvious way I've seen to implement something like this is using C++ inheritance and virtual methods, so let's start with that.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Generated.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Generated&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Generated.cpp&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="n"&gt;Generated&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Impl.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Generated&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;The good&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen doesn't need to know Impl's concrete name or header&lt;/li&gt;
&lt;li&gt;Codegen can easily add codegen-private state&lt;/li&gt;
&lt;li&gt;Codegen methods may be defined out-of-line&lt;/li&gt;
&lt;li&gt;No unsafe type casting&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The bad&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen must write concrete types for each overrideable method&lt;ul&gt;
&lt;li&gt;This means that the overrides are less flexible&lt;/li&gt;
&lt;li&gt;Could lead to codegen-ing ugly &lt;code&gt;const int&amp;amp;&lt;/code&gt; signatures or similar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unavoidable virtual function call overhead &amp;amp; vtable&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Curious Recurring Template Pattern&lt;/h3&gt;
&lt;p&gt;The most common solution to the virtual method approach I've seen is to use the Curious Recurring Template Pattern. This allows avoidng many of the virtual dispatch downsides, at the cost of requiring generated code end up in a header.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Generated.h&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Generated&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// NOTE: Must be inline!&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Impl.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Generated&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;The good&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen doesn't need to know Impl's concrete name or header&lt;/li&gt;
&lt;li&gt;Codegen can easily add codegen-private state&lt;/li&gt;
&lt;li&gt;No virtual call overhead &amp;amp; no vtable&lt;/li&gt;
&lt;li&gt;Generated method calls can adapt to Impl's implementation with templates&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The bad&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Every method of Generated needs to be declared in the header&lt;/li&gt;
&lt;li&gt;Unsafe type casting&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Knowitall Base Class&lt;/h3&gt;
&lt;p&gt;I don't know of a good name for this potential solution. It's a lot like the CRTP approach, except that it takes advantage of the Codegen's ability to include the Impl's definition in its cpp file to avoid the template parameter.&lt;/p&gt;
&lt;p&gt;I call it a Knowitall Class because it claims to know exactly who is subclassing it, and just downcasts the class hierarchy away.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Codegen.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Generated&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Codegen.cpp&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;Impl.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="n"&gt;Generated&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="n"&gt;Generated&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Impl.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Generated&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;The good&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen can easily add codegen-private state&lt;/li&gt;
&lt;li&gt;No virtual call overhead &amp;amp; no vtable&lt;/li&gt;
&lt;li&gt;Generated method calls can adapt to Impl's implementation with templates&lt;/li&gt;
&lt;li&gt;Codegen methods may be defined out-of-line&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The bad&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen needs to know Impl's concrete typename and header&lt;/li&gt;
&lt;li&gt;It's easy to mess up by inheriting a different class from Generated.&lt;ul&gt;
&lt;li&gt;I don't know how big of an issue that this is in most codebases. It could be said that CRTP also has this problem.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unsafe type casting&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Member Declaration Macros&lt;/h3&gt;
&lt;p&gt;This approach uses a macro to inject the needed method declarations directly into the impl class, which avoids the need for the Generated base class which should only have one subclass.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Generated.h&lt;/span&gt;
&lt;span class="cp"&gt;#define DECL_GENERATED_FOR_IMPL() \&lt;/span&gt;
&lt;span class="cp"&gt;    public:                       \&lt;/span&gt;
&lt;span class="cp"&gt;        int RouteCall(int to);    \&lt;/span&gt;
&lt;span class="cp"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* ... */&lt;/span&gt;&lt;span class="cp"&gt;                     \&lt;/span&gt;
&lt;span class="cp"&gt;    public:&lt;/span&gt;

&lt;span class="c1"&gt;// Generated.cpp&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;Impl.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Impl.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;DECL_GENERATED_FOR_IMPL&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;The good&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;No virtual call overhead &amp;amp; no vtable&lt;/li&gt;
&lt;li&gt;Generated method calls can adapt to Impl's implementation with templates&lt;/li&gt;
&lt;li&gt;Codegen methods may be defined out-of-line&lt;/li&gt;
&lt;li&gt;No unsafe type casting&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The bad&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen needs to know Impl's concrete typename and header&lt;/li&gt;
&lt;li&gt;Cannot easily add codegen-private state&lt;/li&gt;
&lt;li&gt;Uses preprocessor macros, which are a bit ugly to read, write &amp;amp; codegen&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Freestanding Functions&lt;/h3&gt;
&lt;p&gt;Finally, we can take the function-call approach and not declare any methods on Impl at all, instead declaring freestanding methods and using function overloading.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Generated.h&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Generated.cpp&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nf"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Impl.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;The good&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;No virtual call overhead &amp;amp; no vtable&lt;/li&gt;
&lt;li&gt;Generated method calls can adapt to Impl's implementation with templates&lt;/li&gt;
&lt;li&gt;Codegen methods may be defined out-of-line&lt;/li&gt;
&lt;li&gt;No unsafe type casting&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The bad&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen needs to know Impl's concrete typename and header&lt;/li&gt;
&lt;li&gt;Cannot easily add codegen-private member variables / state&lt;/li&gt;
&lt;li&gt;Calls to generated methods don't use standard C++ method call syntax.&lt;/li&gt;
&lt;/ul&gt;</content><category term="mozilla"></category><category term="c++"></category><category term="classes"></category><category term="codegen"></category><category term="oop"></category></entry><entry><title>Cleaning up XPConnect</title><link href="https://mystor.github.io/xpconnect-changelog.html" rel="alternate"></link><published>2018-04-30T08:00:00-04:00</published><updated>2018-04-30T08:00:00-04:00</updated><author><name>Nika Layzell</name></author><id>tag:mystor.github.io,2018-04-30:/xpconnect-changelog.html</id><summary type="html">&lt;p&gt;Recently I was working on &lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1457972"&gt;some patches&lt;/a&gt; to clean up and improve the code in
Gecko's XPConnect module. As they ended up being somewhat complex &amp;amp; required me
obtaining a lot of information about how XPConnect works, I ended up writing
some pretty in-depth commit messages.&lt;/p&gt;
&lt;p&gt;I figured that they were …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently I was working on &lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1457972"&gt;some patches&lt;/a&gt; to clean up and improve the code in
Gecko's XPConnect module. As they ended up being somewhat complex &amp;amp; required me
obtaining a lot of information about how XPConnect works, I ended up writing
some pretty in-depth commit messages.&lt;/p&gt;
&lt;p&gt;I figured that they were pretty much mini blog posts, so I've put them here.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 1: Unify xpconnect cleanup codepaths, r=mccr8&lt;/h3&gt;
&lt;p&gt;It used to be that in XPConnect there were many different pieces of code for
each place where we may need to clean up some untyped values based on their
&lt;code&gt;nsXPTType&lt;/code&gt; information. This was a mess, and meant that every time you needed
to add a new data type you'd have to find every one of these places and add
support for your new type to them.&lt;/p&gt;
&lt;p&gt;In fact, this was bad enough that it appears that I missed some places when
adding my webidl support! Which means that in some edge cases we may clean up
one of these values incorrectly D:!&lt;/p&gt;
&lt;p&gt;This patch adds a new unified method which performs the cleanup by looking at a
&lt;code&gt;nsXPTType&lt;/code&gt; object. The idea is that this function takes a &lt;code&gt;void*&lt;/code&gt; which is
actually a &lt;code&gt;T*&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a value of the &lt;code&gt;nsXPTType&lt;/code&gt; parmaeter. It clears the
value behind the pointer to a valid state such that free-ing the memory would
not cause any leaks. e.g. it free(...)s owned pointers and sets the pointer to
&lt;code&gt;nullptr&lt;/code&gt;, and truncates &lt;code&gt;nsA[C]String&lt;/code&gt; values such that they reference the
static empty string.&lt;/p&gt;
&lt;p&gt;I also modify every one of these custom cleanup codepaths to instead call into
this unified cleanup method.&lt;/p&gt;
&lt;p&gt;This also involved some simplification of helper methods in order to make the
implementation cleaner.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 2: Remove unused code paths in xpconnect, r=mccr8&lt;/h3&gt;
&lt;p&gt;Thanks to the changes in the previous patch, we had some unused code which we
can get rid of. This patch just cleans stuff up a bit.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 3: Remove unnecessary #includes of xptinfo headers, r=mccr8&lt;/h3&gt;
&lt;p&gt;We are going to want to include some "gecko internal" types in more places in
the codebase, and we have unused includes of some of these headers in non-libxul
files.&lt;/p&gt;
&lt;p&gt;This patch just cleans up these unnecssary includes.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 4: Remove dipper types, r=mccr8&lt;/h3&gt;
&lt;p&gt;XPT accrued some weird types and flags over the years, and one of the worst of
these is the "dipper" type flag. This flag was added for &lt;code&gt;ns[C]String&lt;/code&gt; values,
as they needed to be passed indirectly as in and out.&lt;/p&gt;
&lt;p&gt;There was another tool which was added for the same purpose, which was the
"Indirect" behaviour. This flag is set for outparameters by default, and
designates that a value will be passed indirectly, but is also used by jsvals
unconditionally, as jsvals are always passed behind a pointer.&lt;/p&gt;
&lt;p&gt;The effective way that indirect parameters works is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;When calling from C++ into JS code, the parameter data pointer is
   dereferenced an extra time before being passed to conversion methods.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When calling from JS into C++ code, a flag is set on the nsXPTCVariant
   object. This flag is read by the platform-specific call code to cause them to
   pass the pointer value stored in &lt;code&gt;nsXPTCVariant::ptr&lt;/code&gt; as the parameter (which
   points to the &lt;code&gt;nsXPTMiniVariant&lt;/code&gt; member) rather than the value stored in the
   variant, thus causing the value to be passed indirectly.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For reference dipper parmaeters worked in a different manner:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;When calling from C++ into JS code, an extra level of indirection is added to
   the passed-in pointer before passing it to conversion methods, causing the
   pointer passed in to have a "real" type of &lt;code&gt;nsA[C]String**&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When calling from JS into C++ code, a &lt;code&gt;nsA[C]String&lt;/code&gt; object is allocated
   using a custom allocator (which tries to avoid allocating for the first 2
   strings of each type, and after that heap allocates), and the allocation's
   pointer is stored in the variant. The value is not considered as being passed
   "indirectly" for both in and out parameters.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As you can see, these two mechanisms take similar but slightly different
approaches. The most notable difference is that in the Indirect case, the "real"
value is assumed to be stored directly in the &lt;code&gt;nsXPTCVariant&lt;/code&gt; object in the JS
-&amp;gt; C++ case. This was probably not done in the past for &lt;code&gt;ns[C]String&lt;/code&gt; as the
&lt;code&gt;nsXPTCVariant&lt;/code&gt; object did not have enough space to allocate a &lt;code&gt;ns[C]String&lt;/code&gt;
object, as it could only hold 8 bytes of information.&lt;/p&gt;
&lt;p&gt;Fortunately for us, we actually have &lt;em&gt;two&lt;/em&gt; variants of &lt;code&gt;nsXPTCVariant&lt;/code&gt;, the
&lt;code&gt;nsXPTCMiniVariant&lt;/code&gt; is what is used most of the time, such as when calling from
C++ into JS, while the &lt;code&gt;nsXPTCVariant&lt;/code&gt; is what is used when we need to actually
allocate space to store whatever value we're passing ourselves (namely it is
only used in the JS -&amp;gt; C++ case).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nsXPTCVariant&lt;/code&gt; is (almost) always allocated on the stack (It is allocated in a
stack-allocated &lt;code&gt;AutoTArray&lt;/code&gt; with a inline capacity of 8. For reference, the
largest parameter count of a JS-exposed xpt method right now is 14 - I
considered bumping the inline capacity up to 16 to make it so we never need to
heap allocate parmaeters, but it seemed like it should be done in a seperate
bug).&lt;/p&gt;
&lt;p&gt;This object is also already pretty big. It has in it:
 1. a &lt;code&gt;nsXPTCMiniVariant&lt;/code&gt; (8 bytes)
 2. a &lt;code&gt;nsXPTType&lt;/code&gt; (3 bytes)
 3. a &lt;code&gt;void*&lt;/code&gt; for indirect calls (8/4 bytes)
 4. a flag byte (1 byte)&lt;/p&gt;
&lt;p&gt;We only need to add enough space to store a &lt;code&gt;ns[C]String&lt;/code&gt; in the
&lt;code&gt;nsXPTCVariant&lt;/code&gt;, and not in &lt;code&gt;nsXPTCMiniVariant&lt;/code&gt;. My approach to this problem was
to make &lt;code&gt;nsXPTCVariant&lt;/code&gt; actually hold a union of a &lt;code&gt;nsXPTCMiniVariant&lt;/code&gt;, and some
storage space for the other, potentially larger information, which we never need
to store in a MiniVariant.&lt;/p&gt;
&lt;p&gt;This allows us to stack allocate the &lt;code&gt;ns[C]Strings&lt;/code&gt; created by XPConnect and
avoid the use of dipper types entirely, in favour of just using indirect values.
It also allows us to delete some of the now-unnecessary custom allocator code
for &lt;code&gt;ns[C]String&lt;/code&gt; objects.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 5: Use modern JS APIs to root jsval temporaries in XPConnect, r=mccr8&lt;/h3&gt;
&lt;p&gt;When a jsval passed from JS code it needs to be stored in a &lt;code&gt;nsXPTCVariant&lt;/code&gt;
object. This object is not rooted by default, as it is stored in some
C++-allocated memory. Currently, we root the values by adding a custom root
using the &lt;code&gt;js::AddRawValueRoot&lt;/code&gt; API, which is deprecated, and only used by this
code and ErrorResult.&lt;/p&gt;
&lt;p&gt;This also has the unfortunate effect that we cannot support XPCOM arrays of
jsvals, as we cannot root all of the values in the array using this API.&lt;/p&gt;
&lt;p&gt;Fortunately, the JS engine has a better rooting API which we can use here
instead. I make the call context a custom rooter, like the &lt;code&gt;SequenceRooter&lt;/code&gt; type
from WebIDL, and make sure to note every jsval when tracing, both in arrays and
as direct values.&lt;/p&gt;
&lt;p&gt;This should allow us to avoid some hashtable operations with roots when
performing XPConnect calls, and remove a consumer of this gross legacy API.&lt;/p&gt;
&lt;p&gt;In addition it allows us to support arrays. This will be even more useful in the
future when I add support for &lt;code&gt;sequence&amp;lt;T&amp;gt;&lt;/code&gt; (which is a &lt;code&gt;nsTArray&amp;lt;T&amp;gt;&lt;/code&gt;) to xpidl
and xpconnect.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 6: Ensure the extended types list has some basic types with known indexes, r=mccr8&lt;/h3&gt;
&lt;p&gt;Currently &lt;code&gt;XPCVariant&lt;/code&gt; has some code for working with arrays of a series of
basic types. I want to unify and simplify code which works with &lt;code&gt;nsXPTTypes&lt;/code&gt; to
always take the topmost level type (rather than passing in an array element type
when working with an array).&lt;/p&gt;
&lt;p&gt;This is pretty easy for most of XPConnect, but &lt;code&gt;XPCVariant&lt;/code&gt; occasionally needs
to perform calls on made-up array types, which isn't compatible with the current
implementation. Fortunately, it only needs a very small set of array types. This
patch adds a set of simple types (mostly the arithmetic types and
&lt;code&gt;TD_INTERFACE_IS_TYPE&lt;/code&gt; for interfaces) to the extra types array unconditionally
with a known index, for &lt;code&gt;XPCVariant&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An other option I was considering was to consider the value &lt;code&gt;0xff&lt;/code&gt; in the data
byte on &lt;code&gt;nsXPTType&lt;/code&gt; to be a flag which indicates that the array element type is
actually the type immediately following the current &lt;code&gt;nsXPTType&lt;/code&gt; object in
memory, but that was incompatible with many of the existing &lt;code&gt;nsXPTType&lt;/code&gt;
consumers which copy the &lt;code&gt;nsXPTType&lt;/code&gt; objects around (e.g. onto the stack),
rather than always using them by reference, so I decided it was not a good
approach to take.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 7: Eliminate XPCConvert::NativeStringWithSize2JS/JSStringWithSize2Native, r=mccr8&lt;/h3&gt;
&lt;p&gt;XPIDL supports explicitly sized string types. These types currently have to be
handled by a separate entry point into &lt;code&gt;XPCConvert&lt;/code&gt;, and don't share any logic
with the implicitly sized string types.&lt;/p&gt;
&lt;p&gt;If we just add an array length parameter to the basic &lt;code&gt;JSData2Native&lt;/code&gt; and
&lt;code&gt;NativeData2JS&lt;/code&gt; methods we can handle them in the same place as every other
type.&lt;/p&gt;
&lt;p&gt;This also allows us to share a lot of code with non-sized string types, which is
nice :-).&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 8: Remove external consumers of XPCConvert::NativeArray2JS/JSArray2Native, r=mccr8&lt;/h3&gt;
&lt;p&gt;Current XPIDL native arrays currently also require a custom entry point. With
the new arraylen parameter we can handle them in
&lt;code&gt;JSData2Native&lt;/code&gt;/&lt;code&gt;NativeData2JS&lt;/code&gt;. As these methods are more complex and don't
share logic with an existing codepath, I keep them in external helper methods.&lt;/p&gt;</content><category term="mozilla"></category><category term="c++"></category><category term="programming"></category><category term="gecko"></category><category term="xpconnect"></category></entry><entry><title>"Wouldn't it be neat if you could write C++ inline in Rust?"</title><link href="https://mystor.github.io/wouldnt-it-be-neat-p1.html" rel="alternate"></link><published>2017-03-20T07:17:00-04:00</published><updated>2017-03-20T07:17:00-04:00</updated><author><name>Nika Layzell</name></author><id>tag:mystor.github.io,2017-03-20:/wouldnt-it-be-neat-p1.html</id><summary type="html">&lt;p&gt;In June of 2015, I had an idea. At the time, I was obsessed with compilers, and
what was possible to do at compile time. For one of the languages which I was
working on, I got excited by the idea that I could have flawless C++ interop by
embedding …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In June of 2015, I had an idea. At the time, I was obsessed with compilers, and
what was possible to do at compile time. For one of the languages which I was
working on, I got excited by the idea that I could have flawless C++ interop by
embedding all of &lt;a href="https://clang.llvm.org"&gt;clang&lt;/a&gt; inside of the compiler, and
have a special &lt;code&gt;c++ {}&lt;/code&gt; form which would allow you to directly write C++ code
inside the program, and give that code access to the stack variables currently
in scope.&lt;/p&gt;
&lt;p&gt;That language never came into fruition, but at the time I was also interested in
another language, which I was going to use to implement my
language, &lt;a href="https://rust-lang.org"&gt;Rust&lt;/a&gt;. Rust was very interesting to me,
because in 2014 it had been one of the first times I had ever written
"system-level" code. I loved the way it seemed to make everything possible with
apparently no overhead. However, I had run into some problems. I wanted to
use &lt;a href="https://llvm.org"&gt;LLVM&lt;/a&gt; to implement the compiler back-end for the language
I was working on, but the best LLVM bindings were written in C++, and using them
from Rust was a tedious experience, to say the least. No good LLVM bindings were
available yet for Rust, so I would pretty much have to write them myself.&lt;/p&gt;
&lt;p&gt;I, naturally, started wishing that I had the &lt;code&gt;c++ {}&lt;/code&gt; block feature in Rust, to
help me write my new programming language. I really enjoy abusing meta
programming features in languages to let me do things which their creators never
intended, so I started concocting ideas as to how I could implement this using
Rust's unstable plugin infrastructure.&lt;/p&gt;
&lt;p&gt;Thus, &lt;a href="https://github.com/mystor/rust-cpp"&gt;rust-cpp&lt;/a&gt; was born.&lt;/p&gt;
&lt;p&gt;You can still find the code for this original version of rust-cpp, although
you'll have trouble getting it to build, archived under
the
&lt;a href="https://github.com/mystor/rust-cpp/tree/legacy_macros1.1_v0"&gt;&lt;code&gt;legacy_rustc_plugin&lt;/code&gt;&lt;/a&gt; branch.&lt;/p&gt;
&lt;p&gt;This initial version of rust-cpp was built with 2 parts, and remains possibly
the most powerful version of rust-cpp to this day. Firstly, it contained a
procedural macro, &lt;code&gt;cpp!&lt;/code&gt;, which would perform the Rust codegen, and store
the information parsed in some global state, and then a lint pass, which would
discover the type information for the callsites, and actually generate and compile
the C++ code.&lt;/p&gt;
&lt;p&gt;An example use of this API might look like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;: &lt;span class="kt"&gt;i32&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;: &lt;span class="kt"&gt;i32&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cpp_result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;unsafe&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-&amp;gt; &lt;span class="kt"&gt;i32&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This invocation would "capture" the local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in the &lt;code&gt;cpp!&lt;/code&gt;
closure, exposing those variable names to the C++ code. the closure itself then
would return a &lt;code&gt;i32&lt;/code&gt;. The C++ code would be contained with a function
invocation, such that the interface looks correct.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;cpp!&lt;/code&gt; macro expansion would produce some code which would look something
like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cp"&gt;#[link(name = &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rust_cpp_tmp&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;, kind = &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;static&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;rust_cpp_936DA01F9ABD4d9d80C702AF85C822A8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;: &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;: &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-&amp;gt; &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rust_cpp_936DA01F9ABD4d9d80C702AF85C822A8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It would then also record the information parsed from the declaration (the names
of the arguments, the body text extracted from the original span as a string,
etc.) in the global storage.&lt;/p&gt;
&lt;p&gt;Then, the lint pass would run. It would walk the typechecked AST, looking at
every function call. If the function call begain with the name &lt;code&gt;rust_cpp_&lt;/code&gt;, it
would be considered as a &lt;code&gt;rust-cpp&lt;/code&gt; call. The matching function would be looked
up from global storage.&lt;/p&gt;
&lt;p&gt;We would then look at the pre-casting types of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and try to guess the
C++ type from them. If we failed, we would default to passing an opaque type to
C++.&lt;/p&gt;
&lt;p&gt;Once the lint pass had seen every function call which was generated earlier by
the &lt;code&gt;cpp!&lt;/code&gt; procedural macro, it would write out a &lt;code&gt;rust_cpp_tmp.cpp&lt;/code&gt; file, which
would then be shelled out to the native c++ compiler. The above function would
have been generated similar to the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/******************************&lt;/span&gt;
&lt;span class="cm"&gt; * Code Generated by Rust-C++ *&lt;/span&gt;
&lt;span class="cm"&gt; ******************************/&lt;/span&gt;

&lt;span class="cm"&gt;/* cstdint includes sane type definitions for integer types */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;cstdint&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* the rs:: namespace contains rust-defined types */&lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;rs&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* A slice from rust code */&lt;/span&gt;
    &lt;span class="cm"&gt;/* Can be used to interact with, pass around, and return Rust slices */&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Slice&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;  &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;uintptr_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="cm"&gt;/* A string slice is simply a slice of utf-8 encoded characters */&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;Slice&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;StrSlice&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* A trait object is composed of a data pointer and a vtable */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;TraitObject&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;vtable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="cm"&gt;/* A dummy struct which is generated when incompatible types are closed-over */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;__Dummy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


    &lt;span class="cm"&gt;/* Typedefs for integral and floating point types */&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="n"&gt;u16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;u64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;usize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int8_t&lt;/span&gt; &lt;span class="n"&gt;i8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;i16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int32_t&lt;/span&gt; &lt;span class="n"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int64_t&lt;/span&gt; &lt;span class="n"&gt;i64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int64_t&lt;/span&gt; &lt;span class="n"&gt;isize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;f32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C++ `float` isn&amp;#39;t 32 bits wide&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C++ `double` isn&amp;#39;t 64 bits wide&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* We use this bool type to ensure that our bools are 1 byte wide */&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;i8&lt;/span&gt; &lt;span class="n"&gt;bool_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* User-generated function declarations */&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;i32&lt;/span&gt; &lt;span class="n"&gt;rust_cpp_936DA01F9ABD4d9d80C702AF85C822A8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;i32&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;i32&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int32_t&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int32_t&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code would then use an
&lt;a href="https://github.com/mystor/rust-cpp/blob/legacy_rustc_plugin/src/lint.rs#L206-L221"&gt;ugly hack&lt;/a&gt; to
insert the compiled static library into the &lt;code&gt;SearchPaths&lt;/code&gt; object, causing it to
be linked in when the compiler performs the final link step.&lt;/p&gt;
&lt;p&gt;This plugin was pretty cool. It could allow you to embed arbitrary C++ code into
your Rust code, was fairly easy to add, and inferred a lot of types for you to
boot! Unfortunately, it required unstable Rust, which meant that people
definitely couldn't use it, and also meant that I had to push a new version very
frequently to keep up with bustage.&lt;/p&gt;
&lt;p&gt;Eventually, I decided to rewrite &lt;code&gt;rust-cpp&lt;/code&gt;, and shed some of the cool features,
in persuit of it working on stable Rust, but that's a story for part 2.&lt;/p&gt;</content><category term="rust"></category><category term="rust-cpp"></category><category term="c++"></category><category term="ffi"></category></entry><entry><title>ClojureScript + Meteor</title><link href="https://mystor.github.io/clojurescript-meteor.html" rel="alternate"></link><published>2014-04-27T08:14:00-04:00</published><updated>2014-04-27T08:14:00-04:00</updated><author><name>Nika Layzell</name></author><id>tag:mystor.github.io,2014-04-27:/clojurescript-meteor.html</id><summary type="html">&lt;p&gt;A few weeks ago, I released a plugin for Meteor, &lt;a href="https://github.com/mystor/meteor-clojurescript"&gt;meteor-clojurescript&lt;/a&gt;. The goal of this plugin was to make developing with Meteor in ClojureScript as easy as with any of the other languages which Meteor supports. The plugin certainly isn't at that state yet, but it's getting closer.&lt;/p&gt;
&lt;p&gt;Meteor has …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A few weeks ago, I released a plugin for Meteor, &lt;a href="https://github.com/mystor/meteor-clojurescript"&gt;meteor-clojurescript&lt;/a&gt;. The goal of this plugin was to make developing with Meteor in ClojureScript as easy as with any of the other languages which Meteor supports. The plugin certainly isn't at that state yet, but it's getting closer.&lt;/p&gt;
&lt;p&gt;Meteor has a build system which it uses for compiling and aggregating files.  Whenever a file changes, it walks the project's directory structure, calling package-provided callbacks for each file with a specific extension it finds.  This callback can then add raw css and javascript assets to the project, which will be compiled and served.&lt;/p&gt;
&lt;p&gt;This system works very well with compile-to-js languages like CoffeeScript, as they map one source file to one javascript output file. Working with languages with more complicated relationships (such as less files), has always been a bit of a pain point in Meteor (all @imported less files have to be given the extension &lt;code&gt;.lessimport&lt;/code&gt;, as every file with the extension &lt;code&gt;.less&lt;/code&gt; is compiled seperately).  &lt;/p&gt;
&lt;p&gt;Choosing the leiningen &lt;code&gt;project.clj&lt;/code&gt; file which accompanies most ClojureScript projects as the base file to compile, it is possible to fire &lt;code&gt;lein cljsbuild once&lt;/code&gt; every time a file changes, which will cause the clojurescript to be compiled into a file (presumably in an ignored directory), which is then read and provided to Meteor. Unfortunately, this is unacceptably slow. Every time &lt;code&gt;lein cljsbuild once&lt;/code&gt; is called, the JVM has to start up (twice), Clojure has to bootstrap itself, the ClojureScript compiler needs to initialize, the directory structure must be analyzed, and every file must be compiled, then the Google Closure compiler must be run to merge the inputs. On my computer, this would consistently take ~ 60 seconds on a small test project.&lt;/p&gt;
&lt;p&gt;That was unacceptable. Fortunately, the problem of faster compile times had already been, at least partially, solved. The command &lt;code&gt;lein cljsbuild auto&lt;/code&gt; would start the JVM and initialize the ClojureScript compiler, and then watch the directory structure for changes.  Whenever something changed, it would recompile (only the differences), and produce a new output file. Using &lt;code&gt;lein cljsbuild auto&lt;/code&gt;, compilations often only a few seconds (after the initial startup and first compile).&lt;/p&gt;
&lt;p&gt;By configuring leiningen to output the compiled code into a folder watched by Meteor, we could then cause the Meteor asset pipeline to re-run whenever the ClojureScript code was changed. &lt;/p&gt;
&lt;p&gt;However, simply dropping the JS code into the directory structure would be a bad idea, as source maps would not be correctly handled by Meteor, which would make development with ClojureScript much more difficult. In addition, the code generated by the &lt;code&gt;:nodejs&lt;/code&gt; target includes &lt;code&gt;require()&lt;/code&gt; calls, and a shebang at the top of the file, which would cause an error if passed into Meteor.&lt;/p&gt;
&lt;p&gt;To solve this problem, the code outputted by leiningen was given a &lt;code&gt;.cjs&lt;/code&gt; extension, and the sourcemap was outputted into the same directory. A Meteor extension handler was then created for the &lt;code&gt;.cjs&lt;/code&gt; extension, which would both load the source map, and perform the transformations on the code generated by the &lt;code&gt;:nodejs&lt;/code&gt; target.&lt;/p&gt;
&lt;p&gt;The leiningen subprocess was also started when the compiler plugin was loaded, and run in the background, such that a seperate leiningen process would not have to be started for development.&lt;/p&gt;
&lt;p&gt;This works fairly well, and you can use it today (just &lt;code&gt;mrt add clojurescript&lt;/code&gt;), however it has a few problems:
 - Meteor Smart Packages are completely unsupported, every top level project has exactly one ClojureScript compile target, and it is defined by the &lt;code&gt;project.clj&lt;/code&gt; file in the root of the project. This isn't as big of a problem (due to the package system already avaliable through leiningen for ClojureScript), and it does make sense to not have multiple copies of the ClojureScript/Closure core libraries.
 - Explicit control over which files are compiled is needed, rather than the implicit mechanism which is generally used by Meteor, meaning that ClojureScript doesn't feel as much like it is part of the Meteor ecosystem
 - Advanced compilation is not yet fully supported, as an externs file for Meteor hasn't been made, so any calls to the Meteor APIs will be munged
 - The compiler creates intermediate files on the disk within the project directory&lt;/p&gt;
&lt;p&gt;However, the potential in using Meteor's powerful reactivity API with the expressive power of ClojureScript is great. I can only see the plugin getting better as I gain familiarity with ClojureScript and the Meteor plugin system. For example, I have done some initial work on a hiccup-style templating interface for meteor-clojurescript, and it is turning out quite well.&lt;/p&gt;</content><category term="meteor"></category><category term="clojure"></category><category term="clojurescript"></category><category term="integration"></category></entry></feed>